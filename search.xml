<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql主从配置(基于docker)]]></title>
    <url>%2F2019%2F01%2F17%2Fmysql%E4%B8%BB%E4%BB%8E%E9%85%8D%E7%BD%AE-%E5%9F%BA%E4%BA%8Edocker%2F</url>
    <content type="text"><![CDATA[Mysql主从配置(基于docker)安装docker12345yum-config-manager --add-repo http://mirrors.aliyun.com/dockerce/linux/centos/docker-ce.repo使用阿里下载源 yum -y install docker-ce 安装高版本 安装启动mysql 5.6docker pull mysql:5.6:安装mysql5.6 docker run --name mysql -v /mysql/my.cnf:/etc/mysql/my.cnf -p 3306:3306 -e MYSQL_ROOT_PASSWORD=&#39;123456&#39; -d mysql:5.6 :启动mysql 将配置文件挂载到/mysql/my.cnf 没有默认创建文件夹==不是==文件,会报错. ​ 开启主从配置文件配置主机在master上 修改外挂的配置文件 my.cnf 1234[mysqld]log-bin=mysql-binserver-id=196 //同一局域网类必须唯一,一般设为ipbinlog-ignore-db=mysql //复制过滤 一般不同步mysql 进入docker容器 docker exec -it 容器名 /bin/bash mysql中创建用户 grant replication slave on *.* to username@&#39;%&#39; identified by password 123%代表所有用户都可以连,可以换成ip地址增加安全性username:用户名password:密码 show master status:记录下==file==和==position==的值 ps:记录下值后不要继续操作master,避免值发生改变 配置从机​ 在slave上面修改my.cnf文件 123456[mysqld]server-id=129##开启二进制日志功能,以备salve作为其他slave的master时使用log-bin=mysql-slave-binbinlog-ignore-db=mysqlrelay_log=mysql-relay-bin binlog :记录下所有数据的更改,可用于本机数据恢复和主从同步 relaylog: mysql主节点将binlog写入本地,从节点定时请求增量binlog，主节点将binlog同步到从节点。 从节点单独进程会将binlog 拷贝至本地 relaylog中。 change master to master_host=&#39;192.168.159.128&#39;, master_user=&#39;slave&#39;, master_password=&#39;123456&#39;, master_port=3306, master_log_file=&#39;mysql-bin.000001&#39;, master_log_pos= 2830, master_connect_retry=30; 1234567master_port:mysql主节点的地址master_user：主机中创建的用户 一般不适用rootmaster_password：主机中创建的用户密码master_port:端口号master_log_file：主机中记录下的file值master_log_pos:主机中记录的position值master_connect_retry:如果连接失败,重试的时间间隔，单位是s,默认60s start slave:开启主从 show slave status\G 1234正常情况下SlaveIORunning和SlaveSQLRunning都是yesSlaveIORunning为connecting 检查连接地址,账号密码和文件是否正确]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoDb]]></title>
    <url>%2F2018%2F12%2F05%2FmongoDb%2F</url>
    <content type="text"><![CDATA[update类型 Type Number Alias Notes Double 1 “double” String 2 “string” Object 3 “object” Array 4 “array” Binary data 5 “binData” Undefined 6 “undefined” Deprecated. ObjectId 7 “objectId” Boolean 8 “bool” Date 9 “date” Null 10 “null” Regular Expression 11 “regex” DBPointer 12 “dbPointer” Deprecated. JavaScript 13 “javascript” Symbol 14 “symbol” Deprecated. JavaScript (with scope) 15 “javascriptWithScope” 32-bit integer 16 “int” Timestamp 17 “timestamp” 64-bit integer 18 “long” Decimal128 19 “decimal” New in version 3.4. Min key -1 “minKey” Max key 127 “maxKey” 更新操作 id 字段，一旦设定，你不能更新id字段,你也不能用有不同 id字段值的替换文档来替换已经存在的文档。并且id字段始终是文档中的第一个字段 db.collection.updateOne() : 即使可能有==多个文档==通过过滤条件匹配到，但是也最多也==只更新一个==文档 db.collection.updateMany(): 更新所有==通过==过滤条件匹配的文档 db.collection.update():即使可能有多个文档通过过滤条件匹配到，但是也最多也只==更新==或者==替换==一个文档。默认只更新一个文档。要更新多个文档，请使用 multi选项。 db.collection.save(): 如果集合内部已经存在一个相同的id的记录，则会替换已经存在的那条记录。如果不存在，则会插入文档 12345678db.users.update( &#123; &quot;favorites.artist&quot;: &quot;Pisanello&quot; &#125;, &#123; $set: &#123; &quot;favorites.food&quot;: &quot;pizza&quot;, type: 0, &#125;, $currentDate: &#123; lastModified: true &#125; &#125;, &#123; multi: true &#125;) db.collection.update(criteria,objNew,upsert,multi) 1234criretia:查询条件objNew:update对象和一些更新操作符upsert：默认是false.如果不存在update的记录时候插入objNew这个新的文档，true为插入。存在update记录时候则修改这条记录。multi:默认是false.只更新找到的第一条记录。如果为true,把按条件查询出来的记录全部更新 更新操作符 作用描述 $inc {$incl:{field:value}} 对一个数字字段的某个field增加value $set {$set: {field:value } } 将文档中的某个字段field的值设为value $unset {$unset:{field:1}} 删除某个字段 $push {$push:{field:value}} 将value追加到field(数组)里,不存在则会插入$p $pushAll 追加多个值到一个数组字段中 $addToset 加一个值到数组内，而且只有当这个值在数组中不存在时才增加 {$pop:{field:1(-1)}} 删除数组内的一个值，-1表示删除数组内的第一个值，1表示最后一个值 {${pull:{field:value}}} 从数组中删除一个等于value的值 $pushAll 一次删除数组中的多个值 {$rename:{old:new}} 对字段进行重命名 文档替换 db.collection.replaceOne 需要传递一个全新的文档(除id 字段外：id字段是不变的，不能修改，如果包含了id字段，它的值必须与当前的值相同) 123456789db.users.replaceOne( &#123;name:"abc"&#125;, &#123; name: "amy", age: 34, type: 2, status: "P", favorites: &#123; "artist": "Dali", food: "donuts" &#125; &#125;) db.users.update( &#123; name: "xyz" &#125;, &#123; name: "mee", age: 25, type: 1, status: "A", favorites: &#123; "artist": "Matisse", food: "mango" &#125; &#125;)]]></content>
      <categories>
        <category>mogondb</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多客户端使用]]></title>
    <url>%2F2018%2F12%2F04%2F%E5%A4%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[多客户端使用 github上创建多分支,hexo管理master主分支。自己管理分支 ​ 修改配置并保存 在本地gitbash连接远程仓库,使用 git clone +仓库地址 下载到本地 将hexo下的文件夹复制到刚刚clone到本地的文件夹中 12&gt; 有多个.git文件夹时候可能会上传失败，保留根目录的.git文件夹&gt; 提交分支 123456&gt; 查看当前分支 如果当前分支为master分支 需要切换到自己管理的分支，然后提交&gt; git branch&gt; git add .&gt; git commit -m &apos;back up &apos;&gt; git push&gt; 其他电脑 12345678910111213&gt; 新电脑的ssh key 添加到github账户上&gt; clone远程仓库的代码 查看当前分支&gt; 切换到 username.github.io目录,需要先执行&gt; npm install(.gitignore忽略了文件)&gt; 提交(注意：当前分支) git pull 查看有无冲突&gt; git add .&gt; git commit -m &apos;back up&apos;(&apos;&apos;里面内容可修改)&gt; git push&gt; hexo部署 hexo server 查看本地&gt; hexo clean &gt; hexo d -g&gt; hexo deploy &gt;]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[docker使用mongoDb]]></title>
    <url>%2F2018%2F12%2F04%2Fdocker%E4%BD%BF%E7%94%A8mongoDb%2F</url>
    <content type="text"><![CDATA[安装mongodb 从docke hub上获取下载地址 默认版本信息为(latest) 如需其他版本也可在docker hub中查找 运行镜像基本执行 123456&gt; docker run --name mongo -d mongo:tag&gt; --name 别名&gt; -d 后台执行&gt; mongo:tag：下载的mongodb版本 默认为latest&gt; 默认端口:27017&gt; 持久化 在宿主机上创建一个数据存储目录（/etc/data/mongodb），将其映射到容器中的目录中。将数据库文件存储在主机系统，便于主机系统上的工具和应用程序访问文件 mkdir -p /etc/data/mongodb docker run –name mongo -v /etc/data/mongodb:/data/db -d mongo 坑: 使用命令 docker ps 查看运行容器 发现容器没有启动 使用命令docker ps -a 查看 发现容器已经退出 使用命令docker logs (containerId) 查看日志信息 提示权限不够 在运行命令加上 –privileged=true 1docker run --name mongo -v /etc/data/mongodb:/data/db --privileged=true -d mongo 如果提示容器名已在使用（is already in use ）docker rm mongo 容器启动后，运行如下命令以管理员进入终端命令行 1docker exec -it mongo mongo admin 可以看到 /etc/data/mongodb 目录下已存在数据]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>数据库</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swagger注解]]></title>
    <url>%2F2018%2F12%2F04%2FSwagger%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解详解 @Api() : 用于类(controller)；标识这个类是swagger的资源 123tags: 表示说明,设置这个值、value的值会被覆盖value: url的路径值description: 对api资源的描述 @ApiOperation() :用于方法(controller里面的方法); 123value:url的路径值tags:设置这个值，value的值会被覆盖description：对该方法的描述 @ApiParame:属性描述，用于解释方法中的参数 1234name:属性名称value：属性值required:是否属性必填hidden:隐藏该属性 @ApiResponse:请求返回信息描述,用于controller方法之上 12code: 请求返回的状态码（http请求码）message：信息描述 @ApiModel() : 用于返回对象类上,对类进行说明；描述返回对象的意义 @ApiModelProperty: 描述一个model的属性。]]></content>
      <categories>
        <category>Swagger</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,Hexo]]></title>
    <url>%2F2018%2F12%2F03%2FHello-Hexo%2F</url>
    <content type="text"></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
